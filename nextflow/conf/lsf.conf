
///////////
// CONDA //
///////////

def denovowestEnvLocation = "../misc/conda/denovowest.yml"


///////////////
// CONTAINER //
///////////////

// TODO : Some processes (e.g. RATE_STATS) fail because their script is not accessible in the container
// if I do not include the following lines. There is likely a better way to do this 
nextflowDir = "$PWD"
nextflowCanonicalDir = new File(nextflowDir).canonicalPath
dnwDir = new File(nextflowCanonicalDir).parent

singularity {
    runOptions = "--bind " + dnwDir
}

// TODO : Had to add the path to the python binary on the container. 
docker {
    runOptions = "-e PATH=$PATH:/opt/view/bin -v " + dnwDir + ":" + dnwDir
}


/////////////
// PROCESS //
/////////////


process {

    conda = denovowestEnvLocation

    // LSF sanger
    executor = 'lsf'
    
    // Requirements for default process
    cpus   = { check_max( 1 , 'cpus', 'normal') }
    time   = { check_max( 10.h * task.attempt, 'time', 'normal') }

    // Increasing the memory when retrying a job does not work for the hard limit (-M), we have to update it manually
	clusterOptions = {
        def memMb = check_max( 2.GB * task.attempt, 'memory', 'normal').toMega()
        return "-M ${memMb} -R 'select[mem>=${memMb}] rusage[mem=${memMb}]' -G team29-grp"
    }

    // Error handling
    errorStrategy = { task.exitStatus in ((130..145) + 104) ? 'retry' : 'finish' }
    maxRetries    = 2
    maxErrors     = '-1'


    // Requirements for long running processes
    withLabel:process_long {
        time   = { check_max( 48.h * task.attempt, 'time', 'long') }
        queue = 'long'
    }

    // Requirements for memory intensive process
    withLabel:intensive {
        time   = { check_max( 48.h * task.attempt, 'time', 'long') }
        queue = 'long'

        clusterOptions = {
            def memMb = check_max( 40.GB * task.attempt, 'memory', 'long').toMega()
            return "-M ${memMb} -R 'select[mem>=${memMb}] rusage[mem=${memMb}]' -G team29-grp"
        }

    }


}


def check_max(obj, type, queue) {

    def defaults = [
        normal: [ max_memory: 256.GB, max_time: 12.h, max_cpus: 8 ],
        long   : [ max_memory: 256.GB, max_time: 48.h, max_cpus: 8 ],
    ]

    def limits = defaults.get(queue, defaults.normal)

    try {
        switch (type) {
            case 'memory':
                def maxMem = limits.max_memory as nextflow.util.MemoryUnit
                return obj > maxMem ? maxMem : obj
            case 'time':
                def maxTime = limits.max_time as nextflow.util.Duration
                return obj > maxTime ? maxTime : obj
            case 'cpus':
                def maxCpus = limits.max_cpus as int
                return Math.min(obj as int, maxCpus)
            default:
                throw new IllegalArgumentException("Unknown resource type: $type")
        }
    } catch (Exception e) {
        println "   ### ERROR ###   Problem checking $type limit for queue '${queue}': ${e.message}. Using default value: $obj"
        return obj
    }
}
